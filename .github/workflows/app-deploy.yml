name: App Deployment

on:
  repository_dispatch:
    types: [trigger-deployment]
  workflow_dispatch:

concurrency:
  group: app-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Guard job to check branch and username
  pre-check:
    runs-on: self-hosted
    outputs:
      can_deploy: ${{ steps.set-output.outputs.can_deploy }}
    steps:
      - name: Check if deployment should run
        id: set-output
        run: |
          echo "ref=${{ github.ref }}"
          echo "event_name=${{ github.event_name }}"
          echo "actor=${{ github.actor }}"

          CAN_DEPLOY=false

          # Condition 1: Deployments from main branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "✅ Allowed: main branch"
            CAN_DEPLOY=true
          fi

          # Condition 2: Manual trigger + correct actor
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.actor }}" = "Mahesh-Kotakonda" ]; then
            echo "✅ Allowed: manual trigger by Mahesh-Kotakonda"
            CAN_DEPLOY=true
          fi

          if [ "$CAN_DEPLOY" = true ]; then
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️ Not allowed to deploy (must be main branch OR manual trigger by Mahesh-Kotakonda)"
            echo "can_deploy=false" >> $GITHUB_OUTPUT
          fi

  deploy:
    needs: pre-check
    if: needs.pre-check.outputs.can_deploy == 'true'
    runs-on: self-hosted
    environment:
      name: production

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      IMAGE_REPO: multi-cloud-cost-and-service-status-dashboard-repo
      SSM_PARAM_NAME: myapp_database_credentials
      S3_JSON_PATH: s3://multi-cloud-cost-and-service-status-dashboard/infra/multi-cloud-dashboard-outputs.json

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Fetch DB credentials from SSM
        run: |
          PARAM_VALUE=$(aws ssm get-parameter --name "$SSM_PARAM_NAME" --with-decryption --query "Parameter.Value" --output text)
          DB_USER=$(echo $PARAM_VALUE | jq -r '.username')
          DB_PASS=$(echo $PARAM_VALUE | jq -r '.password')
          echo "DB_USER=$DB_USER" >> $GITHUB_ENV
          echo "DB_PASS=$DB_PASS" >> $GITHUB_ENV

      - name: Deploy Worker
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
          aws s3 cp "$S3_JSON_PATH" worker-outputs.json
          DB_HOST=$(jq -r '.db.endpoint | split(":")[0]' worker-outputs.json)
          DB_NAME=$(jq -r '.db.name' worker-outputs.json)
          INSTANCE_IDS=$(jq -r '.ec2_instance_ids[]' worker-outputs.json)
      
          for ID in $INSTANCE_IDS; do
            IP=$(aws ec2 describe-instances --instance-ids $ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
      
            # Remove previous failed container
            ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
              "sudo docker rm -f worker_new >/dev/null 2>&1 || true"
      
            # Deploy new container with explicit AWS and DB credentials
            ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
              "docker login -u '$DOCKERHUB_USERNAME' --password-stdin <<< '$DOCKERHUB_TOKEN'; \
               docker pull $DOCKERHUB_USERNAME/$IMAGE_REPO:worker-latest; \
               docker run -d --name worker_new \
                 -e AWS_ACCESS_KEY_ID='$AWS_ACCESS_KEY_ID' \
                 -e AWS_SECRET_ACCESS_KEY='$AWS_SECRET_ACCESS_KEY' \
                 -e AWS_REGION='$AWS_REGION' \
                 -e DB_HOST='$DB_HOST' \
                 -e DB_NAME='$DB_NAME' \
                 -e DB_USER='$DB_USER' \
                 -e DB_PASS='$DB_PASS' \
                 -e POLL_INTERVAL_SECONDS=60000 \
                 $DOCKERHUB_USERNAME/$IMAGE_REPO:worker-latest"
      
            echo "⏳ Waiting for worker_new to stabilize on $IP ..."
            sleep 30
      
            STATUS=$(ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
              "sudo docker ps --filter 'name=worker_new' --filter 'status=running' | grep worker_new >/dev/null 2>&1; echo \$?")
      
            if [ "$STATUS" -eq 0 ]; then
              echo "✅ New worker is healthy on $IP. Replacing old worker..."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                "sudo docker rm -f worker || true; sudo docker rename worker_new worker"
            else
              echo "❌ New worker failed on $IP. Printing logs..."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                "echo '--- Worker Logs (last 200 lines) ---'; \
                 sudo docker logs --tail=200 worker_new || true; \
                 echo '--- Worker Inspect Info ---'; \
                 sudo docker inspect worker_new --format='Status: {{.State.Status}}, ExitCode: {{.State.ExitCode}}, Error: {{.State.Error}}' || true; \
                 sudo docker rm -f worker_new || true"
              echo "⚠️ Rollout stopped. Old worker kept on $IP."
              exit 1
            fi
          done




      #########################################
      # Deploy Backend (Blue-Green Deployment)
      #########################################
      - name: Deploy Backend (Blue-Green)
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
          aws s3 cp "$S3_JSON_PATH" backend-outputs.json
          DB_ENDPOINT=$(jq -r '.db.endpoint' backend-outputs.json)
          DB_HOST=$(echo $DB_ENDPOINT | cut -d: -f1)
          DB_PORT=$(echo $DB_ENDPOINT | cut -d: -f2)
          DB_NAME=$(jq -r '.db.name' backend-outputs.json)
          INSTANCE_IDS=$(jq -r '.ec2_instance_ids[]' backend-outputs.json)
          BACKEND_TARGET_GROUP_ARN=$(jq -r '.backend_target_group_arn' backend-outputs.json)
      
          for ID in $INSTANCE_IDS; do
            IP=$(aws ec2 describe-instances --instance-ids $ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
      
            # Determine current running container (blue or green)
            CURRENT=$(ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
              "docker ps --format '{{.Names}}' | grep backend- || true")
      
            if [ -z "$CURRENT" ]; then
              echo "No backend container found, deploying both blue (8080) and green (8081) for first time..."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                "echo '$DOCKERHUB_TOKEN' | docker login -u '$DOCKERHUB_USERNAME' --password-stdin; \
                 docker pull $DOCKERHUB_USERNAME/$IMAGE_REPO:backend-latest; \
                 docker run -d --name backend-blue \
                   -e DB_HOST='$DB_HOST' -e DB_PORT='$DB_PORT' -e DB_NAME='$DB_NAME' \
                   -e DB_USER='${DB_USER}' -e DB_PASS='${DB_PASS}' \
                   -p 8080:8000 \
                   $DOCKERHUB_USERNAME/$IMAGE_REPO:backend-latest; \
                 docker run -d --name backend-green \
                   -e DB_HOST='$DB_HOST' -e DB_PORT='$DB_PORT' -e DB_NAME='$DB_NAME' \
                   -e DB_USER='${DB_USER}' -e DB_PASS='${DB_PASS}' \
                   -p 8081:8000 \
                   $DOCKERHUB_USERNAME/$IMAGE_REPO:backend-latest"
              # Register blue in ALB target group
              aws elbv2 register-targets --target-group-arn ${BACKEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=8080
            else
              if [[ "$CURRENT" == "backend-blue" ]]; then
                echo "Blue running → deploy green on 8081"
                ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                  "docker rm -f backend-green || true; \
                   docker run -d --name backend-green \
                     -e DB_HOST='$DB_HOST' -e DB_PORT='$DB_PORT' -e DB_NAME='$DB_NAME' \
                     -e DB_USER='${DB_USER}' -e DB_PASS='${DB_PASS}' \
                     -p 8081:8000 \
                     $DOCKERHUB_USERNAME/$IMAGE_REPO:backend-latest"
                # Switch ALB to green
                aws elbv2 register-targets --target-group-arn ${BACKEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=8081
                aws elbv2 deregister-targets --target-group-arn ${BACKEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=8080
              else
                echo "Green running → deploy blue on 8080"
                ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                  "docker rm -f backend-blue || true; \
                   docker run -d --name backend-blue \
                     -e DB_HOST='$DB_HOST' -e DB_PORT='$DB_PORT' -e DB_NAME='$DB_NAME' \
                     -e DB_USER='${DB_USER}' -e DB_PASS='${DB_PASS}' \
                     -p 8080:8000 \
                     $DOCKERHUB_USERNAME/$IMAGE_REPO:backend-latest"
                # Switch ALB to blue
                aws elbv2 register-targets --target-group-arn ${BACKEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=8080
                aws elbv2 deregister-targets --target-group-arn ${BACKEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=8081
              fi
            fi
          done
      
      #########################################
      # Deploy Frontend (Blue-Green Deployment)
      #########################################
      - name: Deploy Frontend (Blue-Green)
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
          aws s3 cp "$S3_JSON_PATH" frontend-outputs.json
          INSTANCE_IDS=$(jq -r '.ec2_instance_ids[]' frontend-outputs.json)
          FRONTEND_TARGET_GROUP_ARN=$(jq -r '.frontend_target_group_arn' frontend-outputs.json)
      
          for ID in $INSTANCE_IDS; do
            IP=$(aws ec2 describe-instances --instance-ids $ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
      
            CURRENT=$(ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
              "docker ps --format '{{.Names}}' | grep frontend- || true")
      
            if [ -z "$CURRENT" ]; then
              echo "No frontend container found, deploying both blue (3000) and green (3001)..."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                "echo '$DOCKERHUB_TOKEN' | docker login -u '$DOCKERHUB_USERNAME' --password-stdin; \
                 docker pull $DOCKERHUB_USERNAME/$IMAGE_REPO:frontend-latest; \
                 docker run -d --name frontend-blue -p 3000:3000 \
                   $DOCKERHUB_USERNAME/$IMAGE_REPO:frontend-latest; \
                 docker run -d --name frontend-green -p 3001:3000 \
                   $DOCKERHUB_USERNAME/$IMAGE_REPO:frontend-latest"
              # Register blue in ALB TG
              aws elbv2 register-targets --target-group-arn ${FRONTEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=3000
            else
              if [[ "$CURRENT" == "frontend-blue" ]]; then
                echo "Blue running → deploy green on 3001"
                ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                  "docker rm -f frontend-green || true; \
                   docker run -d --name frontend-green -p 3001:3000 \
                     $DOCKERHUB_USERNAME/$IMAGE_REPO:frontend-latest"
                aws elbv2 register-targets --target-group-arn ${FRONTEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=3001
                aws elbv2 deregister-targets --target-group-arn ${FRONTEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=3000
              else
                echo "Green running → deploy blue on 3000"
                ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" \
                  "docker rm -f frontend-blue || true; \
                   docker run -d --name frontend-blue -p 3000:3000 \
                     $DOCKERHUB_USERNAME/$IMAGE_REPO:frontend-latest"
                aws elbv2 register-targets --target-group-arn ${FRONTEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=3000
                aws elbv2 deregister-targets --target-group-arn ${FRONTEND_TARGET_GROUP_ARN} --targets Id=$ID,Port=3001
              fi
            fi
          done




