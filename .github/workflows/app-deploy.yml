name: App Deployment

on:
  repository_dispatch:
    types: [trigger-deployment]
  workflow_dispatch:
    inputs:
      components:
        description: "Which components to deploy (all, worker, backend, frontend, or comma-separated list)"
        required: true
      worker_version:
        description: "Version tag for worker (default: latest)"
        required: false
        default: "latest"
      backend_version:
        description: "Version tag for backend (default: latest)"
        required: false
        default: "latest"
      frontend_version:
        description: "Version tag for frontend (default: latest)"
        required: false
        default: "latest"

concurrency:
  group: app-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ##########################
  # Pre-check deployment
  ##########################
  pre-check:
    runs-on: self-hosted
    outputs:
      can_deploy: ${{ steps.set-output.outputs.can_deploy }}
      components: ${{ steps.parse-inputs.outputs.components }}
      worker_version: ${{ steps.parse-inputs.outputs.worker_version }}
      backend_version: ${{ steps.parse-inputs.outputs.backend_version }}
      frontend_version: ${{ steps.parse-inputs.outputs.frontend_version }}
    steps:
      - name: Check if deployment should run
        id: set-output
        run: |
          CAN_DEPLOY=false
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            CAN_DEPLOY=true
          fi
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.actor }}" = "Mahesh-Kotakonda" ]; then
            CAN_DEPLOY=true
          fi
          echo "can_deploy=$CAN_DEPLOY" >> $GITHUB_OUTPUT

      - name: Parse and validate inputs
        id: parse-inputs
        run: |
          COMPONENTS="${{ github.event.inputs.components }}"
          WORKER_VER="${{ github.event.inputs.worker_version }}"
          BACKEND_VER="${{ github.event.inputs.backend_version }}"
          FRONTEND_VER="${{ github.event.inputs.frontend_version }}"

          COMPONENTS=$(echo "$COMPONENTS" | tr '[:upper:]' '[:lower:]')

          VALID_COMPONENTS=(all worker backend frontend)
          for comp in $(echo $COMPONENTS | tr ',' ' '); do
            if [[ ! " ${VALID_COMPONENTS[@]} " =~ " $comp " ]]; then
              echo "Invalid component: $comp. Allowed: all, worker, backend, frontend."
              exit 1
            fi
          done

          if [[ "$COMPONENTS" == *"all"* && "$COMPONENTS" != "all" ]]; then
            echo "If you want to deploy all components, you must set components=all only. Do not combine 'all' with others."
            exit 1
          fi

          echo "Manual inputs received:"
          echo "  components=$COMPONENTS"
          echo "  worker_version=$WORKER_VER"
          echo "  backend_version=$BACKEND_VER"
          echo "  frontend_version=$FRONTEND_VER"

          echo "components=$COMPONENTS" >> $GITHUB_OUTPUT
          echo "worker_version=$WORKER_VER" >> $GITHUB_OUTPUT
          echo "backend_version=$BACKEND_VER" >> $GITHUB_OUTPUT
          echo "frontend_version=$FRONTEND_VER" >> $GITHUB_OUTPUT

  ##########################
  # Resolve Images
  ##########################
  resolve-images:
    needs: pre-check
    if: needs.pre-check.outputs.can_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      worker_image: ${{ steps.resolve.outputs.worker_image }}
      backend_image: ${{ steps.resolve.outputs.backend_image }}
      frontend_image: ${{ steps.resolve.outputs.frontend_image }}
    steps:
      - name: Resolve images
        id: resolve
        run: |
          COMPONENTS="${{ needs.pre-check.outputs.components }}"
          IMAGE_REPO="multi-cloud-cost-and-service-status-dashboard-repo"
          USER="${{ secrets.DOCKERHUB_USERNAME }}"

          WORKER_IMAGE=""
          BACKEND_IMAGE=""
          FRONTEND_IMAGE=""

          if [[ "$COMPONENTS" == "all" || "$COMPONENTS" == *"worker"* ]]; then
            TAG="${{ needs.pre-check.outputs.worker_version }}"
            WORKER_IMAGE="$USER/$IMAGE_REPO-worker:$TAG"
          fi

          if [[ "$COMPONENTS" == "all" || "$COMPONENTS" == *"backend"* ]]; then
            TAG="${{ needs.pre-check.outputs.backend_version }}"
            BACKEND_IMAGE="$USER/$IMAGE_REPO-backend:$TAG"
          fi

          if [[ "$COMPONENTS" == "all" || "$COMPONENTS" == *"frontend"* ]]; then
            TAG="${{ needs.pre-check.outputs.frontend_version }}"
            FRONTEND_IMAGE="$USER/$IMAGE_REPO-frontend:$TAG"
          fi

          echo "Resolved images:"
          echo "  Worker   : $WORKER_IMAGE"
          echo "  Backend  : $BACKEND_IMAGE"
          echo "  Frontend : $FRONTEND_IMAGE"

          echo "worker_image=$WORKER_IMAGE" >> $GITHUB_OUTPUT
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT

  ##########################
  # Deploy Worker
  ##########################
  deploy_worker:
    needs: [pre-check, resolve-images]
    if: needs.pre-check.outputs.can_deploy == 'true'
    runs-on: self-hosted
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Determine deployment mode
        id: resolve-image
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            COMPONENTS="${{ needs.pre-check.outputs.components }}"
            if [[ "$COMPONENTS" == "all" || "$COMPONENTS" == *"worker"* ]]; then
              IMAGE="${{ needs.resolve-images.outputs.worker_image }}"
              if [ -z "$IMAGE" ]; then
                echo "ERROR: worker_image output from resolve-images is empty."
                exit 1
              fi
              echo "Manual mode detected. Worker image: $IMAGE"
            else
              echo "Skipping worker deployment: not requested in components."
              exit 0
            fi
          else
            if [ -z "${{ github.event.client_payload.worker }}" ]; then
              echo "Skipping worker deployment: no worker image in client payload."
              exit 0
            fi
            IMAGE="${{ github.event.client_payload.worker }}"
            echo "Automatic mode detected. Client payload worker image: $IMAGE"
          fi
      
          echo "WORKER_IMAGE=$IMAGE" >> $GITHUB_ENV


      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Deploy worker to instances
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem

          echo "Downloading infra outputs..."
          aws s3 cp "s3://multi-cloud-cost-and-service-status-dashboard/infra/multi-cloud-dashboard-outputs.json" worker-outputs.json

          DB_HOST=$(jq -r '.db.endpoint | split(":")[0]' worker-outputs.json)
          DB_NAME=$(jq -r '.db.name' worker-outputs.json)
          INSTANCE_IDS=$(jq -r '.ec2_instance_ids[]' worker-outputs.json)

          SUCCESSFUL=()
          FAILED=0

          for ID in $INSTANCE_IDS; do
            IP=$(aws ec2 describe-instances --instance-ids $ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
            echo "Deploying worker to instance $ID ($IP) with image $WORKER_IMAGE"

            ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" "
              docker rm -f worker_new >/dev/null 2>&1 || true && \
              echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME }}' --password-stdin && \
              docker pull $WORKER_IMAGE && \
              docker run -d --name worker_new \
                -e AWS_ACCESS_KEY_ID='${{ secrets.AWS_ACCESS_KEY_ID }}' \
                -e AWS_SECRET_ACCESS_KEY='${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
                -e AWS_REGION='us-east-1' \
                -e DB_HOST='$DB_HOST' \
                -e DB_NAME='$DB_NAME' \
                -e DB_USER='${{ secrets.DB_USER }}' \
                -e DB_PASS='${{ secrets.DB_PASS }}' \
                -e POLL_INTERVAL_SECONDS=60000 \
                $WORKER_IMAGE"

            sleep 20
            STATUS=$(ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" "docker ps --filter 'name=worker_new' --filter 'status=running' | grep worker_new >/dev/null 2>&1; echo $?")

            if [ "$STATUS" -eq 0 ]; then
              echo "Deployment succeeded on instance $ID"
              SUCCESSFUL+=("$ID")
            else
              echo "Deployment failed on instance $ID"
              echo "Fetching container logs before cleanup..."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" "docker logs worker_new || true"
              echo "Removing failed container on $ID"
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" "docker rm -f worker_new || true"
              FAILED=1
              break
            fi
          done

          if [ $FAILED -eq 1 ]; then
            echo "One or more instances failed. All successful instances will be cleaned up."
            for ID in "${SUCCESSFUL[@]}"; do
              IP=$(aws ec2 describe-instances --instance-ids $ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
              echo "Removing worker_new container from $ID due to rollback."
              ssh -o StrictHostKeyChecking=no -i "$PEM_PATH" ec2-user@"$IP" "docker rm -f worker_new || true"
            done
            exit 1
          fi

          echo "All instances deployed successfully. Promotion (rename) will be handled in the final job."



  ##########################
  # Deploy Backend
  ##########################
  deploy_backend:
    needs: deploy_worker
    runs-on: self-hosted
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      IMAGE_REPO: multi-cloud-cost-and-service-status-dashboard-repo
      S3_JSON_PATH: s3://multi-cloud-cost-and-service-status-dashboard/infra/multi-cloud-dashboard-outputs.json
      SSM_PARAM_NAME: myapp_database_credentials
    outputs:
      backend_status: ${{ steps.deploy_backend.outputs.backend_status }}
      backend_active_env: ${{ steps.deploy_backend.outputs.backend_active_env }}
      backend_current_image: ${{ steps.deploy_backend.outputs.backend_current_image }}
      backend_previous_image: ${{ steps.deploy_backend.outputs.backend_previous_image }}
      backend_blue_tg: ${{ steps.deploy_backend.outputs.backend_blue_tg }}
      backend_green_tg: ${{ steps.deploy_backend.outputs.backend_green_tg }}
      backend_deployed_at: ${{ steps.deploy_backend.outputs.backend_deployed_at }}
      backend_deployed_by: ${{ steps.deploy_backend.outputs.backend_deployed_by }}
  
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fetch DB credentials and instance info
        id: fetch_db
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
  
          echo "Downloading backend JSON from S3..."
          aws s3 cp "$S3_JSON_PATH" backend-outputs.json
  
          # Fetch DB host, port, and name from JSON
          DB_ENDPOINT=$(jq -r '.db.endpoint' backend-outputs.json)
          DB_HOST=$(echo $DB_ENDPOINT | cut -d':' -f1)
          DB_PORT=$(echo $DB_ENDPOINT | cut -d':' -f2)
          DB_NAME=$(jq -r '.db.name' backend-outputs.json)
  
          INSTANCE_IDS=$(jq -r '.ec2_instance_ids | join(",")' backend-outputs.json)
          BLUE_TG=$(jq -r '.backend_blue_tg_arn' backend-outputs.json)
          GREEN_TG=$(jq -r '.backend_green_tg_arn' backend-outputs.json)
  
          # Fetch DB credentials from SSM
          PARAM_VALUE=$(aws ssm get-parameter --name "$SSM_PARAM_NAME" --with-decryption --query "Parameter.Value" --output text)
          DB_USER=$(echo $PARAM_VALUE | jq -r '.username')
          DB_PASS=$(echo $PARAM_VALUE | jq -r '.password')
  
          # Export to GitHub environment
          echo "DB_HOST=$DB_HOST" >> $GITHUB_ENV
          echo "DB_PORT=$DB_PORT" >> $GITHUB_ENV
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
          echo "DB_USER=$DB_USER" >> $GITHUB_ENV
          echo "DB_PASS=$DB_PASS" >> $GITHUB_ENV
          echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV
          echo "BACKEND_BLUE_TG=$BLUE_TG" >> $GITHUB_ENV
          echo "BACKEND_GREEN_TG=$GREEN_TG" >> $GITHUB_ENV
  
      - name: Deploy Backend (Blue-Green)
        id: deploy_backend
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
          ./deploy/deploy-backend.sh \
            --outputs-json backend-outputs.json \
            --pem-path "$PEM_PATH" \
            --db-host "$DB_HOST" \
            --db-port "$DB_PORT" \
            --db-name "$DB_NAME" \
            --db-user "$DB_USER" \
            --db-pass "$DB_PASS" \
            --dockerhub-username "$DOCKERHUB_USERNAME" \
            --dockerhub-token "$DOCKERHUB_TOKEN" \
            --image-tag "${{ github.event.client_payload.backend }}" \
            --instance-ids "$INSTANCE_IDS" \
            --blue-tg "$BACKEND_BLUE_TG" \
            --green-tg "$BACKEND_GREEN_TG" \
            --aws-access-key-id "$AWS_ACCESS_KEY_ID" \
            --aws-secret-access-key "$AWS_SECRET_ACCESS_KEY" \
            --aws-region "$AWS_REGION"




  ##########################
  # Deploy Frontend
  ##########################
  deploy_frontend:
    needs: deploy_backend
    runs-on: self-hosted
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      IMAGE_REPO: multi-cloud-cost-and-service-status-dashboard-repo
      S3_JSON_PATH: s3://multi-cloud-cost-and-service-status-dashboard/infra/multi-cloud-dashboard-outputs.json
    outputs:
      frontend_status: ${{ steps.deploy_frontend.outputs.frontend_status }}
      frontend_active_env: ${{ steps.deploy_frontend.outputs.frontend_active_env }}
      frontend_current_image: ${{ steps.deploy_frontend.outputs.frontend_current_image }}
      frontend_previous_image: ${{ steps.deploy_frontend.outputs.frontend_previous_image }}
      frontend_blue_tg: ${{ steps.deploy_frontend.outputs.frontend_blue_tg }}
      frontend_green_tg: ${{ steps.deploy_frontend.outputs.frontend_green_tg }}
      frontend_deployed_at: ${{ steps.deploy_frontend.outputs.frontend_deployed_at }}
      frontend_deployed_by: ${{ steps.deploy_frontend.outputs.frontend_deployed_by }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy Frontend (Blue-Green)
        id: deploy_frontend
        run: |
          PEM_PATH=~/ssh-keys/multi-cloud-cost-and-service-status-key.pem
          aws s3 cp "$S3_JSON_PATH" frontend-outputs.json
          ./deploy/deploy-frontend.sh \
            --outputs-json frontend-outputs.json \
            --pem-path "$PEM_PATH" \
            --dockerhub-username "${DOCKERHUB_USERNAME}" \
            --dockerhub-token "${DOCKERHUB_TOKEN}" \
            --image-tag "${{ github.event.client_payload.frontend }}" \
            --instance-ids "$(jq -r '.ec2_instance_ids | join(",")' frontend-outputs.json)" \
            --blue-tg "$(jq -r '.frontend_blue_tg_arn' frontend-outputs.json)" \
            --green-tg "$(jq -r '.frontend_green_tg_arn' frontend-outputs.json)" \
            --aws-access-key-id "${AWS_ACCESS_KEY_ID}" \
            --aws-secret-access-key "${AWS_SECRET_ACCESS_KEY}" \
            --aws-region "${AWS_REGION}"


  ##########################
  # Deploy Metadata
  ##########################
  deploy_metadata:
    needs: [deploy_worker, deploy_backend, deploy_frontend]
    runs-on: self-hosted
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      IMAGE_REPO: multi-cloud-cost-and-service-status-dashboard-repo
      DEPLOY_METADATA_S3_BUCKET: multi-cloud-cost-and-service-status-dashboard
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download infra outputs JSON
        run: |
          S3_JSON_PATH="s3://multi-cloud-cost-and-service-status-dashboard/infra/multi-cloud-dashboard-outputs.json"
          aws s3 cp "$S3_JSON_PATH" infra-outputs.json
          echo "infra_outputs_json=infra-outputs.json" >> $GITHUB_ENV

          INSTANCE_IDS=$(jq -r '.ec2_instance_ids | join(",")' infra-outputs.json)
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_ENV

          LISTENER_ARN=$(jq -r '.alb_listener_arn' infra-outputs.json)
          echo "listener_arn=$LISTENER_ARN" >> $GITHUB_ENV
          
      - name: Print job outputs for debugging
        run: |
          echo "Worker Current Image: ${{ needs.deploy_worker.outputs.worker_current_image }}"
          echo "Worker Previous Image: ${{ needs.deploy_worker.outputs.worker_previous_image }}"
          echo "Worker Status: ${{ needs.deploy_worker.outputs.worker_status }}"
          echo "Backend Current Image: ${{ needs.deploy_backend.outputs.backend_current_image }}"
          echo "Backend Previous Image: ${{ needs.deploy_backend.outputs.backend_previous_image }}"
          echo "Backend Blue TG: ${{ needs.deploy_backend.outputs.backend_blue_tg }}"
          echo "Backend Green TG: ${{ needs.deploy_backend.outputs.backend_green_tg }}"
          echo "Backend Active Env: ${{ needs.deploy_backend.outputs.backend_active_env }}"
          echo "Frontend Current Image: ${{ needs.deploy_frontend.outputs.frontend_current_image }}"
          echo "Frontend Previous Image: ${{ needs.deploy_frontend.outputs.frontend_previous_image }}"
          echo "Frontend Blue TG: ${{ needs.deploy_frontend.outputs.frontend_blue_tg }}"
          echo "Frontend Green TG: ${{ needs.deploy_frontend.outputs.frontend_green_tg }}"
          echo "Frontend Active Env: ${{ needs.deploy_frontend.outputs.frontend_active_env }}"
          echo "Instance IDs: ${{ env.instance_ids }}"
          echo "Listener ARN: ${{ env.listener_arn }}"
          echo "Infra Outputs JSON: ${{ env.infra_outputs_json }}"
          echo "DockerHub Username: ${{ env.DOCKERHUB_USERNAME }}"
          echo "AWS Access Key: ${{ env.AWS_ACCESS_KEY_ID }}"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo "Image Repo: ${{ env.IMAGE_REPO }}"
          echo "S3 Bucket: ${{ env.DEPLOY_METADATA_S3_BUCKET }}"
          echo "GitHub Actor: ${{ github.actor }}"


      - name: Run metadata.py
        run: |
          python3 ./deploy/metadata.py \
            --pem-path ~/ssh-keys/multi-cloud-cost-and-service-status-key.pem \
            --worker-current-image "${{ needs.deploy_worker.outputs.worker_current_image }}" \
            --worker-previous-image "${{ needs.deploy_worker.outputs.worker_previous_image }}" \
            --worker-status "${{ needs.deploy_worker.outputs.worker_status }}" \
            --backend-current-image "${{ needs.deploy_backend.outputs.backend_current_image }}" \
            --backend-previous-image "${{ needs.deploy_backend.outputs.backend_previous_image }}" \
            --frontend-current-image "${{ needs.deploy_frontend.outputs.frontend_current_image }}" \
            --frontend-previous-image "${{ needs.deploy_frontend.outputs.frontend_previous_image }}" \
            --instance-ids "${{ env.instance_ids }}" \
            --backend-blue-tg "${{ needs.deploy_backend.outputs.backend_blue_tg }}" \
            --backend-green-tg "${{ needs.deploy_backend.outputs.backend_green_tg }}" \
            --backend-active-env "${{ needs.deploy_backend.outputs.backend_active_env }}" \
            --frontend-blue-tg "${{ needs.deploy_frontend.outputs.frontend_blue_tg }}" \
            --frontend-green-tg "${{ needs.deploy_frontend.outputs.frontend_green_tg }}" \
            --frontend-active-env "${{ needs.deploy_frontend.outputs.frontend_active_env }}" \
            --infra-outputs-json "${{ env.infra_outputs_json }}" \
            --dockerhub-username "${{ env.DOCKERHUB_USERNAME }}" \
            --dockerhub-token "${{ env.DOCKERHUB_TOKEN }}" \
            --aws-access-key-id "${{ env.AWS_ACCESS_KEY_ID }}" \
            --aws-secret-access-key "${{ env.AWS_SECRET_ACCESS_KEY }}" \
            --aws-region "${{ env.AWS_REGION }}" \
            --image-repo "${{ env.IMAGE_REPO }}" \
            --listener-arn "${{ env.listener_arn }}" \
            --s3-bucket "${{ env.DEPLOY_METADATA_S3_BUCKET }}" \
            --github-actor "${{ github.actor }}"
